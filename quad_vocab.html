<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Quad Vocab — ES · DE · RU · EN</title>
  <style>
    :root{
      --bg: #0f172a;
      --panel: #0b1220;
      --muted: #94a3b8;
      --text: #e5e7eb;
      --accent: #60a5fa;
      --error: #ef4444;
      --gap: 12px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background: linear-gradient(180deg,#04060a 0%, var(--bg) 45%);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica, Arial, "Noto Sans";
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      display:flex;
      align-items:stretch;
      justify-content:center;
    }

    /* Make the app take the full viewport while leaving a compact header/search area */
    .app{
      width:100%;
      max-width:1300px;
      height:100vh;
      padding:18px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }

    .brand {
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    h1{ margin:0; font-size:18px; font-weight:700; letter-spacing:0.2px; }
    .sub{ margin:0; color:var(--muted); font-size:13px; }

    /* Search bar compact on top */
    .searchbar{
      display:flex;
      align-items:center;
      gap:8px;
      width:540px;
      max-width:100%;
    }
    .searchbar input{
      flex:1;
      padding:12px 14px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.04);
      background: rgba(255,255,255,0.02);
      color:var(--text);
      font-size:14px;
      outline:none;
    }
    .searchbar input:focus{
      box-shadow:0 0 0 3px rgba(96,165,250,0.06);
      border-color: rgba(96,165,250,0.35);
    }
    .searchbar button{
      padding:10px 12px;
      border-radius:10px;
      border:0;
      background:rgba(255,255,255,0.03);
      color:var(--text);
      cursor:pointer;
      font-weight:600;
    }
    .error{
      margin-top:6px;
      padding:8px 10px;
      border-radius:8px;
      background: rgba(239,68,68,0.12);
      color:#fecaca;
      border:1px solid rgba(239,68,68,0.25);
      display:none;
    }

    /* RESULT area — this must take as much vertical space as possible */
    .result{
      flex:1; /* fill remaining space under header/search */
      display:flex;
      align-items:stretch;
      justify-content:stretch;
      gap:var(--gap);
      min-height:0; /* important for flex children to size properly */
    }

    /* Hide results area until user searches */
    .result.hidden{ display:none; }

    /* The 2x2 matrix grid taking most of the screen */
    .card-grid{
      display:grid;
      grid-template-columns: repeat(2, 1fr);
      grid-auto-rows: 1fr;
      gap:var(--gap);
      width:100%;
      align-content:stretch;
      align-items:stretch;
      justify-items:stretch;
    }

    /* Each translation card fills its cell */
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.006));
      border: 1px solid rgba(255,255,255,0.03);
      border-radius:14px;
      padding:20px;
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:flex-start;
      gap:10px;
      min-height:0;
      perspective:1000px; /* enable 3D flip */
      cursor:pointer;
    }

    /* Flip card internals */
    .card-inner{
      position:relative;
      width:100%;
      height:100%;
      transform-style:preserve-3d;
      transition: transform 400ms ease;
    }
    .card.flipped .card-inner{ transform: rotateY(180deg); }
    .card-face{
      position:absolute;
      inset:0;
      padding:0;
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:flex-start;
      gap:10px;
      backface-visibility:hidden;
    }
    .card-face.back{ transform: rotateY(180deg); }

    /* Make the displayed word large — responsive */
    .lang {
      font-size:13px;
      color:var(--muted);
      display:flex;
      gap:10px;
      align-items:center;
      width:100%;
    }
    .lang b { color:var(--text); font-weight:700; }

    .word{
      font-weight:800;
      font-size: clamp(28px, 6vw, 72px);
      line-height:1;
      letter-spacing:0.2px;
      width:100%;
      word-break:break-word;
    }

    .meta { color:var(--muted); font-size:13px; }

    /* Make sure small screens still look good — stack two rows */
    @media (max-width:900px){
      .card-grid{ grid-template-columns: repeat(2, 1fr); grid-auto-rows: 1fr; }
    }
    @media (max-width:600px){
      .card-grid{ grid-template-columns: 1fr; grid-auto-rows: minmax(120px, auto); }
      .searchbar{ width:100%; }
    }

    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); border: 0; }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Spanish, German, Russian, English vocabulary search">
    <header>
      

      <div style="display:flex;flex-direction:column;align-items:flex-end;gap:6px;">
        <div class="searchbar" role="search" aria-label="Search translations">
          <label for="q" class="sr-only">Search a word</label>
          <input id="q" name="q" type="search" placeholder="Try: casa · Haus · дом · house" autocomplete="off" enterkeyhint="search" list="words" />
          <button id="searchBtn" aria-label="Search">Search</button>
        </div>
        <div id="error" class="error" role="alert" aria-live="polite"></div>
      </div>
    </header>

    <datalist id="words"></datalist>
    <main id="result" class="result hidden" aria-live="polite"></main>
  </div>

  <script>
    /* Demo dictionary — extend or replace with backend JSON */
    const DICTIONARY = [
      { id: 1, en: "house",     es: "casa",      de: "Haus",      ru: "дом",       pos: "noun", forms: ["houses","casas","Häuser","дома","домов"] },
      { id: 2, en: "cat",       es: "gato",      de: "Katze",     ru: "кот",       pos: "noun", forms: ["cats","gatos","кошки","Katzen"] },
      { id: 3, en: "to eat",    es: "comer",     de: "essen",     ru: "есть",      pos: "verb", forms: ["eats","ate","eating","como","comes","come","comemos","esst","isst","ешь","ест","едят"] },
      { id: 4, en: "red",       es: "rojo",      de: "rot",       ru: "красный",   pos: "adj",  forms: ["roja","rojos","rote","rotes","красная","красные"] },
      { id: 5, en: "book",      es: "libro",     de: "Buch",      ru: "книга",     pos: "noun", forms: ["books","libros","Bücher","книги"] },
      { id: 6, en: "water",     es: "agua",      de: "Wasser",    ru: "вода",      pos: "noun", forms: ["aguas","воды"] },
      { id: 7, en: "hello",     es: "hola",      de: "hallo",     ru: "привет",    pos: "expr" },
      { id: 8, en: "car",       es: "coche",     de: "Auto",      ru: "машина",    pos: "noun", forms: ["autos","авто","машины","coches"] },
      { id: 9, en: "school",    es: "escuela",   de: "Schule",    ru: "школа",     pos: "noun", forms: ["escuelas","Schulen","школы","schools"] },
      { id:10, en: "computer",  es: "ordenador", de: "Computer",  ru: "компьютер", pos: "noun", forms: ["computers","ordenadores","компьютеры"] },
    ];

    const byId = id => document.getElementById(id);
    const $q = byId("q"), $res = byId("result"), $err = byId("error"), $btn = byId("searchBtn");

    const normalize = s => (s||"").toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');

    // Build fast index for exact/form matches
    const INDEX = (() => {
      const map = new Map();
      for (const e of DICTIONARY) {
        for (const key of ["en","es","de","ru"]) {
          const token = normalize(e[key]);
          if (!map.has(token)) map.set(token, new Set());
          map.get(token).add(e.id);
        }
        if (e.forms) {
          for (const f of e.forms) {
            const token = normalize(f);
            if (!map.has(token)) map.set(token, new Set());
            map.get(token).add(e.id);
          }
        }
      }
      return map;
    })();

    function search(query){
      const qn = normalize(query.trim());
      if (!qn) return [];
      const ids = INDEX.get(qn);
      if (ids) {
        const set = Array.from(ids);
        return DICTIONARY.filter(e => set.includes(e.id));
      }
      // simple partial fallback
      return DICTIONARY.filter(e =>
        ["en","es","de","ru"].some(k => normalize(e[k]).includes(qn))
      );
    }

    function posLabel(p){
      const map = { noun: "Noun", verb: "Verb", adj: "Adjective", adv: "Adverb", expr: "Expression" };
      return map[p] || p;
    }

    function escapeHTML(s){
      return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;").replaceAll("'","&#39;");
    }

    // Render a 2x2 matrix from provided translations
    function renderTranslations(map, query, detected){
      $res.innerHTML = "";
      $err.style.display = "none";
      const missing = !map || (!map.es && !map.de && !map.ru && !map.en);
      if (missing) {
        $err.textContent = `No results for “${query}”.`;
        $err.style.display = "block";
        return;
      }

      const grid = document.createElement("div");
      grid.className = "card-grid";
      grid.setAttribute("aria-label", `Translations for ${query}`);

      const det = (detected || "").toLowerCase();
      const mk = (code, lang, word) => {
        const isDetected = det === code.toLowerCase();
        const displayWord = isDetected ? query : (word || "");
        return card(code, lang, displayWord, null, isDetected);
      };
      grid.innerHTML = `
        ${mk("ES","Spanish", map.es)}
        ${mk("DE","German",  map.de)}
        ${mk("RU","Russian", map.ru)}
        ${mk("EN","English", map.en)}
      `;

      $res.appendChild(grid);
    }

    function card(short, lang, word, pos, reveal){
      const flippedClass = reveal ? " flipped" : "";
      return `
        <article class="card${flippedClass}" data-lang="${short}" role="button" tabindex="0" aria-pressed="${reveal}" aria-label="${lang} card">
          <div class="card-inner">
            <div class="card-face front">
              <div class="lang"><b>${short}</b><span style="opacity:.9;">${lang}</span></div>
              <div class="word" style="opacity:.7; font-weight:700; font-size: clamp(20px, 3.8vw, 40px);">${lang}</div>
              <div class="meta" style="opacity:.6;">Tap to reveal</div>
            </div>
            <div class="card-face back">
              <div class="lang"><b>${short}</b><span style="opacity:.9;">${lang}</span></div>
              <div class="word">${escapeHTML(word)}</div>
              <div class="meta">${pos ? posLabel(pos) : ""}</div>
            </div>
          </div>
        </article>
      `;
    }

    // With hardcoded dictionary only, no external API

    async function doSearch(){
      const q = ($q.value || "").trim();
      if (!q){
        $res.innerHTML = "";
        $res.classList.add("hidden");
        $err.textContent = "Type a word to translate.";
        $err.style.display = "block";
        return;
      }

      $err.style.display = "none";
      $res.innerHTML = "";
      $res.classList.remove("hidden");

      // Find best matching entry and detect which language user typed
      const results = search(q);
      if (results && results.length){
        const e = results[0];
        const qn = normalize(q);
        let detected = "";
        if (normalize(e.es) === qn) detected = "es";
        else if (normalize(e.de) === qn) detected = "de";
        else if (normalize(e.ru) === qn) detected = "ru";
        else if (normalize(e.en) === qn) detected = "en";
        renderTranslations({ es: e.es, de: e.de, ru: e.ru, en: e.en }, q, detected);
      } else {
        $err.textContent = `No results for “${q}”.`;
        $err.style.display = "block";
        $res.classList.add("hidden");
      }
    }

    // Toggle flip on click/Enter/Space (event delegation)
    $res.addEventListener("click", e => {
      const card = e.target.closest(".card");
      if (!card) return;
      card.classList.toggle("flipped");
      card.setAttribute("aria-pressed", String(!card.classList.contains("flipped")));
    });
    $res.addEventListener("keydown", e => {
      if (e.key !== "Enter" && e.key !== " ") return;
      const card = e.target.closest(".card");
      if (!card) return;
      e.preventDefault();
      card.classList.toggle("flipped");
      card.setAttribute("aria-pressed", String(!card.classList.contains("flipped")));
    });

    $btn.addEventListener("click", doSearch);
    $q.addEventListener("keydown", e => { if (e.key === "Enter") doSearch(); });
    // live (debounced)
    let t = null;
    $q.addEventListener("input", () => { clearTimeout(t); t = setTimeout(doSearch, 180); });

    // On load: no default word, keep results hidden
    window.addEventListener("DOMContentLoaded", () => {
      $q.value = "";
      // Populate datalist with hardcoded 10 words across all four languages
      const $dl = document.getElementById("words");
      if ($dl){
        const seen = new Set();
        for (const e of DICTIONARY){
          for (const key of ["en","es","de","ru"]){
            const val = e[key];
            const norm = normalize(val);
            if (!seen.has(norm)){
              seen.add(norm);
              const opt = document.createElement("option");
              opt.value = val;
              $dl.appendChild(opt);
            }
          }
        }
      }
    });
  </script>
</body>
</html>
